1. 尽量指定类、方法的final修饰符(?)
    - 正：带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。
    为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。
    Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。
    - 驳：在java早期的时候，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，当编译器发现final方法调用命令时，
    它会根据自己谨慎的判断，跳过插入程序代码这种正常方法而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），
    并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。
    当然，如果一个方法很大，你的程序代码就会膨胀，因而可能开不到内嵌带来的任何的提高，因为，所带来的性能提高会因为花费于方法内的时间量而被缩减。
    在最近的java版本中，虚拟机（特别是hotspot技术）可以探测到这些情况，并且优化去掉这些效率反而降低的额外的内嵌调用，
    因此不再需要使用final方法来进行优化了。
    - Own：暂时不使用这种方法，jvm发展到现在，已经不用了这样了，作为知识储备。
    
2. 尽量重用对象
    - 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。
    由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响
    - Own：静态字符串拼接，jvm会帮助你处理
    ```
    String test = "this " + "is " + "a " + "test " + "string";
    ```
    拼接动态字符串,StringBuffer 或 StringBuilder的 append,减少构造过多的临时 String 对象
    
3. 尽可能使用局部变量
    - 调用方法时*传递的参数*以及在调用中创建的*临时变量*都保存在*栈*中速度较快，
    其他变量，如*静态变量*、*实例变量*等，都在*堆*中创建，速度较慢。
    另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。
    
4. 及时关闭流
    - Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。
    因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。
